"""
CMSC 14100
Autumn 2022

Test code for Homework #5
"""

import json
import os
import sys
import traceback
import pytest
import test_helpers as helpers
import image_helpers as ih


# Handle the fact that the test code may not
# be in the same directory as the solution code
sys.path.insert(0, os.getcwd())

# Don't complain about the position of the import
# pylint: disable=wrong-import-position
import hw5

MODULE = "hw5"

def check_color(t):
    """
    Verify that t has type (int, int, int) and that the values
    all fall between 0 and 255 inclusive
    """
    return (isinstance(t, tuple) and
            len(t) == 3 and
            all(isinstance(v, int) and 0 <= v <= 255 for v in t))

def check_image(actual, expected, recreate_msg):
    """
    Do the work of checking that the actual image (represented using
    (byte, byte, byte) matches the expected image.
    """

    type_error_msg = ("\nThe actual value does not have the correct type.\n"
                      "Expected a list of list of (int, int, int)\n")
    if recreate_msg is not None:
        type_error_msg += "\n" + recreate_msg
    helpers.check_2D_type(check_color, actual, type_error_msg)

    helpers.check_2D(lambda a, e: e == a,
                     actual, expected, recreate_msg)


def check_image_unmodified(param_name, before, after, recreate_msg=None):
    """
    Generate an error if an image has been modified
    """

    msg = (f"You modified the contents of the parameter: {param_name}, "
           "which is not allowed.\n")
    msg += "  Value before your code at location ({}, {}): {}\n"
    msg += "  Value after your code at location ({}, {}):  {}"
    if recreate_msg is not None:
        msg += "\n" + recreate_msg

    for i, row in enumerate(before):
        for j, before_val in enumerate(row):
            assert before_val == after[i][j], \
                msg.format(i, j, before_val, i, j, after[i][j])


def gen_load_file_str(name_pairs, include_start_str=True):
    """
    Generate the file loading string to include in the
    recreation tests
    """
    if include_start_str:
        rmsg = "\nTo recreate this test in ipython3 run:\n"
        rmsg += "  import hw5\n"
    else:
        rmsg = ""

    rmsg += "  import image_helpers\n"
    for var_name, filename in name_pairs:
        rmsg += f"  {var_name} = image_helpers.load_image('{filename}')\n"
    return rmsg


add_tests = [
    ((0, 0, 0), (5, 6, 7), (5, 6, 7)),
    ((255, 255, 255), (255, 255, 255), (510, 510, 510)),
    ((10, 11, 12), (1, 1, 1), (11, 12, 13))
    ]
@pytest.mark.timeout(60)
@pytest.mark.parametrize("triple1, triple2, expected", add_tests)
def test_add_triples(triple1, triple2, expected):
    """
    Does one test for add_triples
    """
    recreate_msg = helpers.gen_recreate_msg(MODULE, "add_triples",
                                            triple1, triple2)

    try:
        actual = hw5.add_triples(triple1, triple2)
    except Exception as e:
        # catch all exceptions generated by add_triples and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n" + recreate_msg + \
            f"\nException {traceback.format_exc()}"
        assert False, msg

    helpers.check_not_none(actual, recreate_msg)
    helpers.check_tuple(actual, expected, "tuple(int, int, int)", recreate_msg)

scale_tests = [
    ((0, 0, 0), 1/10, (0, 0, 0)),
    ((255*4, 255*4, 255*4), 1/4, (255, 255, 255)),
    ((255*3, 255*3, 255*3), 1/3, (255, 255, 255)),
    ((0*3, 0+0+255, 0+0+124), 1/3, (0, 85, 41)),
    ((1275, 1275, 1020), 1/9,  (141, 141, 113))
]
@pytest.mark.timeout(60)
@pytest.mark.parametrize("triple, factor, expected", scale_tests)
def test_scale_triple(triple, factor, expected):
    """
    Does one test for scale_triple
    """
    recreate_msg = helpers.gen_recreate_msg(MODULE, "scale_triple",
                                            triple, factor)

    try:
        actual = hw5.scale_triple(triple, factor)
    except Exception as e:
        # catch all exceptions generated by add_triples and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n" + recreate_msg + \
            f"\nException {traceback.format_exc()}"
        assert False, msg


    helpers.check_not_none(actual, recreate_msg)
    helpers.check_tuple(actual, expected, "tuple(int, int, int)", recreate_msg)


# Some useful color constants

RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)

@pytest.mark.timeout(60)
@pytest.mark.parametrize("fg_filename, bg_filename, screen_color, loc, expected",
    [("tests/checkerboard_green.ppm", "tests/blue_yellow_stripe.ppm",
      GREEN, (0, 0), BLUE),
     ("tests/checkerboard_green.ppm", "tests/blue_yellow_stripe.ppm",
      GREEN, (5, 4), BLUE),
     ("tests/checkerboard_green.ppm", "tests/blue_yellow_stripe.ppm",
      GREEN, (1, 2), WHITE),
     ("tests/checkerboard_green.ppm", "tests/blue_yellow_stripe.ppm",
      GREEN, (2, 2), BLACK),
     ("tests/checkerboard_green.ppm", "tests/blue_yellow_stripe.ppm",
      GREEN, (5, 1), YELLOW),
     ("tests/checkerboard_green.ppm", "tests/blue_yellow_stripe.ppm",
      RED, (0, 0), GREEN),
     ("tests/checkerboard_green.ppm", "tests/blue_yellow_stripe.ppm",
      RED, (5, 4), GREEN),
     ("tests/checkerboard_green.ppm", "tests/blue_yellow_stripe.ppm",
      WHITE, (1, 2), BLUE),
     ("tests/checkerboard_green.ppm", "tests/blue_yellow_stripe.ppm",
      BLACK, (2, 2), BLUE),
     ("tests/checkerboard_green.ppm", "tests/blue_yellow_stripe.ppm",
      YELLOW, (5, 1), GREEN)])

def test_choose_pixel(fg_filename, bg_filename, screen_color, loc, expected):
    """
    Does one test for choose_pixel
    """
    rmsg = gen_load_file_str([("fg_img", fg_filename),
                              ("bg_img", bg_filename)])
    rmsg += f"  hw5.choose_pixel(fg_img, bg_img, {screen_color}, {loc})\n"

    fg_img = ih.load_image(fg_filename)
    fg_img_copy = ih.load_image(fg_filename)

    bg_img = ih.load_image(bg_filename)
    bg_img_copy = ih.load_image(bg_filename)

    try:
        actual = hw5.choose_pixel(fg_img_copy, bg_img_copy, screen_color, loc)
    except Exception as e:
        # catch all exceptions generated by add_triples and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n\n" + rmsg + \
            f"\n\nException {traceback.format_exc()}"
        assert False, msg

    helpers.check_not_none(actual, rmsg)

    check_image_unmodified("foreground", fg_img, fg_img_copy, rmsg)
    check_image_unmodified("background", bg_img, bg_img_copy, rmsg)

    helpers.check_tuple(actual, expected, "tuple(int, int, int)", rmsg)


with open("tests/combine_images_tests.json", encoding="UTF-8") as f:
    combine_tests = json.load(f)
@pytest.mark.timeout(60)
@pytest.mark.parametrize("fg_filename, bg_filename, screen_color, expected_filename",
                         combine_tests)
def test_combine_images(fg_filename, bg_filename, screen_color, expected_filename):
    """
    Do a single test for combining images
    """
    # JSON does not support tuples
    # convert before the first use
    screen_color = tuple(screen_color)

    rmsg = gen_load_file_str([("fg_img", fg_filename),
                              ("bg_img", bg_filename),
                              ("expected", expected_filename)])
    rmsg += f"  hw5.combine_images(fg_img, bg_img, {screen_color})\n"

    fg_img = ih.load_image(fg_filename)
    fg_img_copy = ih.load_image(fg_filename)

    bg_img = ih.load_image(bg_filename)
    bg_img_copy = ih.load_image(bg_filename)



    try:
        actual = hw5.combine_images(fg_img_copy, bg_img_copy, screen_color)
    except Exception as e:
        # catch all exceptions generated by add_triples and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n\n" + rmsg + \
            f"\n\nException {traceback.format_exc()}"
        assert False, msg

    helpers.check_not_none(actual, rmsg)

    check_image_unmodified("foreground", fg_img, fg_img_copy, rmsg)
    check_image_unmodified("background", bg_img, bg_img_copy, rmsg)

    expected = ih.load_image(expected_filename)
    check_image(actual, expected, rmsg)



with open("tests/count_color_tests.json", encoding="UTF-8") as f:
    is_color_tests = json.load(f)
@pytest.mark.timeout(60)
@pytest.mark.parametrize("tst_dict", is_color_tests)
def test_is_color_in_region(tst_dict):
    """
    Checks count_color_in_region for a given image, region and target color.
    """
    img_filename = tst_dict["image_filename"]
    # convert locs to tuples.
    # do conversion before first use
    region = [tuple(loc) for loc in tst_dict["region"]]
    target_color = tuple(tst_dict["target_color"])

    expected = tst_dict["expected"]

    rmsg = gen_load_file_str([("img", img_filename)])
    rmsg += f"  hw5.is_color_in_region(img, {region}, {target_color})\n"

    img = ih.load_image(img_filename)
    img_copy = ih.load_image(img_filename)

    region_copy = region[:]

    try:
        actual = hw5.is_color_in_region(img_copy, region_copy, target_color)
    except Exception as e:
        # catch all exceptions generated by add_triples and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n\n" + rmsg \
            + f"\n\nException {traceback.format_exc()}"
        assert False, msg

    check_image_unmodified("img", img, img_copy, rmsg)
    helpers.check_list_unmodified("region_locs", region, region_copy, rmsg)

    helpers.check_result(actual, expected, rmsg)

with open("tests/find_region_location_tests.json", encoding="UTF-8") as f:
    find_region_tests = json.load(f)
@pytest.mark.timeout(60)
@pytest.mark.parametrize("tst_dict", find_region_tests)
def test_find_region_locations(tst_dict):
    """
    Checks find_region_locations for a given image, location, and radius
    """
    img_filename = tst_dict["image_filename"]
    loc = tuple(tst_dict["loc"])
    radius = tst_dict["radius"]
    # JSON does not support tuples
    expected = [tuple(t) for t in tst_dict["expected"]]


    rmsg = "\nTo recreate this test in ipython3 run:\n"
    rmsg += "  import image_helpers\n"
    rmsg += "  import hw5\n"
    rmsg += f"  img = image_helpers.load_image('{img_filename}')\n"
    rmsg += f"  hw5.find_region_locations(img, {loc}, {radius})\n"

    img = ih.load_image(img_filename)
    img_copy = ih.load_image(img_filename)
    actual = hw5.find_region_locations(img, loc, radius)

    check_image_unmodified("img", img, img_copy, rmsg)

    # The actual and expected values match, we're done.
    if actual == expected:
        return

    # We expect a result is not None
    helpers.check_not_none(actual, rmsg)

    # We expect a result of the right type
    # Check that actual is a list
    helpers.check_type(actual, expected, rmsg)

    # Check the length of the result
    helpers.check_length(actual, expected, rmsg)

    # Check that the values in the list are tuples of length 2
    msg = ("The {} entry in the actual result has the wrong type or length.\n"
           "The expected type is a tuple of length 2.\n")
    msg1 = msg + "The actual type is {}.\n"
    msg2 = msg + "The actual type is tuple of length {}.\n"
    for i, t in enumerate(actual):
        assert isinstance(t, tuple), msg1.format(i, type(t).__name__) + rmsg
        assert len(t) == 2, msg2.format(i, len(t)) + rmsg

    # We expect a result that has the same pairs, not necessarily in
    # the same order.
    helpers.check_equals(set(actual), set(expected), rmsg)



with open("tests/blur_images_tests.json", encoding="UTF-8") as f:
    blur_tests = json.load(f)
@pytest.mark.timeout(60)
@pytest.mark.parametrize("fg_filename, bg_filename, screen_color, radius, expected_filename",
                         blur_tests)
def test_combine_with_blurring(fg_filename, bg_filename, screen_color, radius, expected_filename):
    """
    Do one test for combining two images with blurring
    """

    # JSON does not support tuples
    # convert before any use
    screen_color = tuple(screen_color)

    rmsg = gen_load_file_str([("fg_img", fg_filename),
                               ("bg_img", bg_filename),
                               ("expected", expected_filename)])
    rmsg += f"  hw5.combine_with_blurring(fg_img, bg_img, {screen_color}, {radius})"

    fg_img = ih.load_image(fg_filename)
    fg_img_copy = ih.load_image(fg_filename)

    bg_img = ih.load_image(bg_filename)
    bg_img_copy = ih.load_image(bg_filename)



    try:
        actual = hw5.combine_with_blurring(fg_img_copy, bg_img_copy,
                                           screen_color, radius)
    except Exception as e:
        msg = f"Exception caught: {e}\n" + rmsg + \
            f"\nTraceback: \n{traceback.format_exc()}"
        assert False, msg

    helpers.check_not_none(actual, rmsg)

    check_image_unmodified("foreground", fg_img, fg_img_copy, rmsg)
    check_image_unmodified("background", bg_img, bg_img_copy, rmsg)

    print("expected_filename:", expected_filename)
    expected = ih.load_image(expected_filename)
    print(expected)
    check_image(actual, expected, rmsg)
