"""
CMSC 14100
Winter 2023

Test code for Homework #6

This code needs work: do a better job of abstracting the
  code for checking the results
"""

import copy
import json
import os
import sys
import traceback
import pytest

from util import get_json_from_file


# Handle the fact that the test code may not
# be in the same directory as the solution code
sys.path.insert(0, os.getcwd())

# Don't complain about the position of the import
# pylint: disable=wrong-import-position
import hw6

MODULE = "hw6"

counting_tests = get_json_from_file("tests/counting_tests.json")

@pytest.mark.parametrize("orig_filename, num_tweets, expected",
                         counting_tests["count_tweets_by_user"])
def test_count_tweets_by_user(orig_filename, num_tweets, expected):
    """
    Do one count tweets by user test
    """
    orig_tweets = get_json_from_file(orig_filename)
    orig_tweets = orig_tweets[:num_tweets]

    recreate_msg = gen_recreate_header(orig_filename, 0, num_tweets) + \
           f"  expected = {str(expected)}\n" + \
           f"  actual = {MODULE}.count_tweets_by_user(tweets)\n"
    
    try:
        actual = hw6.count_tweets_by_user(orig_tweets)
    except Exception as e:
        # catch all exceptions generated by the function and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n" + recreate_msg + \
            f"\nException {traceback.format_exc()}"
        pytest.fail(msg)

    # check that the result is not None
    nn_error = get_none_error(actual)
    if nn_error:
        pytest.fail("\n" + nn_error + recreate_msg)

    # make sure the result is a dictionary
    type_error1 = (f"Expected a dictionary that maps user screen names to integers.\n"
            f"  Actual return type: {type(actual).__name__}\n")
    if not isinstance(actual, type(expected)):
        pytest.fail("\n" + type_error1 + recreate_msg)


    # check the keys
    key_error = get_key_error(actual, expected)
    if key_error:
        pytest.fail("\n" + key_error + recreate_msg)

    # check the values
    for key, cnt in actual.items():
        if not isinstance(cnt, int):
            print("here")
            msg = (f"The expected type for key '{key}' and the actual type do not match:\n"
                   f"  Expected type: int \n"
                   f"  Actual type: {type(actual[key]).__name__}\n")
            pytest.fail("\n" + msg + recreate_msg)

        if expected[key] != cnt:
            msg = (f"The expected value for key '{key}' and the actual value do not match:\n"
                   f"  Expected value: {expected[key]}\n"
                   f"  Actual value: {actual[key]}\n")
            pytest.fail("\n" + msg + recreate_msg)

            
@pytest.mark.parametrize("tweet_index, key, subkey, expected",
                         get_json_from_file("tests/entity_tests.json"))
def test_extract_entity(tweet_index, key, subkey, expected):
    """
    Does one test for extract_entity
    """

    synthetic_tweets = get_json_from_file("tests/synthetic_original_tweets.json")

    recreate_msg = gen_recreate_header('tests/synthetic_original_tweets.json') + \
           f"  {MODULE}.extract_entities(tweets[{tweet_index}], '{key}', '{subkey}')\n"

    tweet = synthetic_tweets[tweet_index]

    try:
        actual = hw6.extract_entities(tweet, key, subkey)
    except Exception as e:
        # catch all exceptions generated by the function and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n" + recreate_msg + \
            f"\nException {traceback.format_exc()}"
        pytest.fail(msg)

    nn_error = get_none_error(actual)
    if nn_error:
        pytest.fail("\n" + nn_error + recreate_msg)

    lst_error = get_list_error(actual, expected, "list[str]")
    if lst_error:
        pytest.fail("\n" + lst_error + recreate_msg)



@pytest.mark.parametrize("orig_tweets_filename, ent_descs, lb, ub, expected_filename",
                         get_json_from_file("tests/process_synthetic_tests.json") + \
                         [("tests/all_uk_tweets.json", None, 0, 10, "tests/all_uk_simple_tweets.json"),
                          ("tests/all_uk_tweets.json", None, 0, 100, "tests/all_uk_simple_tweets.json"),
                          ("tests/all_uk_tweets.json", None, 0, 1000, "tests/all_uk_simple_tweets.json"),
                          ("tests/all_uk_tweets.json", None, None, None, "tests/all_uk_simple_tweets.json")])
def test_process_tweets(orig_tweets_filename, ent_descs, lb, ub, expected_filename):
    """
    Does one test for process_tweets
    """
    tweets = get_json_from_file(orig_tweets_filename)
    tweets = tweets[lb:ub]

    expected = get_json_from_file(expected_filename)
    if lb is not None:
        assert ub is not None
        expected = expected[lb:ub]
        expected_str = f"  expected = util.get_json_from_file('{expected_filename}')[{lb} : {ub}]\n"
    else:
        expected_str = f"  expected = util.get_json_from_file('{expected_filename}')\n"

    if not ent_descs:
        ent_descs = [('hashtags', 'text'),
                     ('urls', 'url'),
                     ('user_mentions', 'screen_name')]

    recreate_msg = gen_recreate_header(orig_tweets_filename, lb, ub) + \
           expected_str + \
           f"  actual = {MODULE}.process_tweets(tweets, {ent_descs})\n"

    try:
        actual = hw6.process_tweets(tweets, ent_descs)
    except Exception as e:
        # catch all exceptions generated by the function and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n" + recreate_msg + \
            f"\nException {traceback.format_exc()}"
        pytest.fail(msg)

    nn_error = get_none_error(actual)
    if nn_error:
        pytest.fail("\n" + nn_error + recreate_msg)

    error_msg = get_tweet_list_error(actual, expected)
    if error_msg:
        pytest.fail("\n" + error_msg + recreate_msg)


@pytest.mark.parametrize("simple_tweets_filename, num_tweets, expected_filename",
                         [("tests/all_uk_simple_tweets.json", 10, "tests/organize_first_10_uk_simple_tweets.json"),
                          ("tests/all_uk_simple_tweets.json", 100, "tests/organize_first_100_uk_simple_tweets.json"),
                          ("tests/all_uk_simple_tweets.json", 1000, "tests/organize_first_1000_uk_simple_tweets.json")])
def test_organize_tweets_by_user(simple_tweets_filename, num_tweets, expected_filename):
    """
    Do one test for organizing tweets by user
    """

    tweets = get_json_from_file(simple_tweets_filename)

    if num_tweets:
        tweets = tweets[:num_tweets]

    expected = get_json_from_file(expected_filename)

    recreate_msg = gen_recreate_header(simple_tweets_filename, 0, num_tweets) + \
        f"  expected = util.get_json_from_file('{expected_filename}')\n" + \
        f"  actual = {MODULE}.organize_tweets_by_user(tweets)\n"

    try:
        actual = hw6.organize_tweets_by_user(tweets)
    except Exception as e:
        # catch all exceptions generated by the function and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n" + recreate_msg + \
            f"\nException {traceback.format_exc()}"
        pytest.fail(msg)

    # check that the result is not None
    nn_error = get_none_error(actual)
    if nn_error:
        pytest.fail("\n" + nn_error + recreate_msg)

    # make sure the result is a dictionary
    msg1 = (f"Expected a dictionary that maps user names to lists of simple tweets.\n"
           f"  Actual return type: {type(actual).__name__}\n")
    if not isinstance(actual, type(expected)):
        pytest.fail("\n" + msg1 + recreate_msg)

    # check the keys
    key_error = get_key_error(actual, expected)
    if key_error:
        pytest.fail("\n" + key_error + recreate_msg)

    # check the values
    msg4 = ("The value associated with the key '{}' in the result is incorrect.\n"
            "It should be a list of simple dictionaries.  The error may be that\n"
            "  - the type of the value is incorrect,\n"
            "  - the length of list is incorrect, or\n"
            "  - the dictionary at a specific index is wrong.\n"
            " Interpret what follows with those possibilities in mind\n\n")
    for key, expected_val in expected.items():
        val_error_msg = get_tweet_list_error(actual[key], expected_val)
        if val_error_msg:
            pytest.fail("\n" + msg4.format(key) + val_error_msg + recreate_msg)


@pytest.mark.parametrize("filename, entity_key, k, expected",
                         counting_tests["find_top_k_entities"])
def test_find_top_k_entities(filename, entity_key, k, expected):
    """
    Do one test for finding top k entities for each user
    """
    tweets_per_user = get_json_from_file(filename)

    recreate_msg = (f"\n\nTo recreate this test in ipython3, run:\n"
                    f"  import util\n"
                    f"  import {MODULE}\n"
                    f"  tweets_per_user = util.get_json_from_file('{filename}')\n"
                    f"  expected = {str(expected)}\n"
                    f"  actual = {MODULE}.find_top_k_entities(tweets_per_user, '{entity_key}', {k})\n")

    try:
        actual = hw6.find_top_k_entities(tweets_per_user, entity_key, k)
    except Exception as e:
        # catch all exceptions generated by the function and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n" + recreate_msg + \
            f"\nException {traceback.format_exc()}"
        pytest.fail(msg)

    # check that the result is not None
    nn_error = get_none_error(actual)
    if nn_error:
        pytest.fail("\n" + nn_error + recreate_msg)

    error_msg = get_user_to_list_error(actual, expected)
    if error_msg:
        pytest.fail("\n" + error_msg + recreate_msg)


@pytest.mark.parametrize("filename, entity_key, min_count, expected",
                         counting_tests["find_min_count_entities"])
def test_find_min_count_entities(filename, entity_key, min_count, expected):
    """
    Do one test for find the entities that occur at least min_count times per user
    """
    tweets_per_user = get_json_from_file(filename)

    recreate_msg = (f"\n\nTo recreate this test in ipython3, run:\n"
                    f"  import util\n"
                    f"  import {MODULE}\n"
                    f"  tweets_per_user = util.get_json_from_file('{filename}')\n"
                    f"  expected = {str(expected)}\n"
                    f"  actual = {MODULE}.find_min_count_entities(tweets_per_user, '{entity_key}', {min_count})\n")

    try:
        actual = hw6.find_min_count_entities(tweets_per_user, entity_key, min_count)
    except Exception as e:
        # catch all exceptions generated by the function and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n" + recreate_msg + \
            f"\nException {traceback.format_exc()}"
        pytest.fail(msg)

    # check that the result is not None
    nn_error = get_none_error(actual)
    if nn_error:
        pytest.fail("\n" + nn_error + recreate_msg)

    error_msg = get_user_to_list_error(actual, expected, True)
    if error_msg:
        pytest.fail("\n" + error_msg + recreate_msg)
    

@pytest.mark.parametrize("filename, n, k, expected",
                         counting_tests["find_top_k_ngrams"])
def test_find_top_k_ngrams(filename, n, k, expected):
    """
    Do one test find top k ngrams per user
    """
    tweets_per_user = get_json_from_file(filename)

    # fix the type of the expected value
    for user, vals in expected.items():
        expected[user] = [tuple(v) for v in vals]

    recreate_msg = (f"\n\nTo recreate this test in ipython3, run:\n"
                    f"  import util\n"
                    f"  import {MODULE}\n"
                    f"  tweets_per_user = util.get_json_from_file('{filename}')\n"
                    f"  expected = {str(expected)}\n"
                    f"  actual = {MODULE}.find_top_k_ngrams(tweets_per_user, {n}, {k})\n")

    try:
        actual = hw6.find_top_k_ngrams(tweets_per_user, n, k)
    except Exception as e:
        # catch all exceptions generated by the function and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n" + recreate_msg + \
            f"\nException {traceback.format_exc()}"
        pytest.fail(msg)

    # check that the result is not None
    nn_error = get_none_error(actual)
    if nn_error:
        pytest.fail("\n" + nn_error + recreate_msg)

    error_msg = get_user_to_list_error(actual, expected)
    if error_msg:
        pytest.fail("\n" + error_msg + recreate_msg)
        

@pytest.mark.parametrize("filename, n, min_count, expected",
                         counting_tests["find_min_count_ngrams"])
def test_find_min_count_ngrams(filename, n, min_count, expected):
    """
    Do one test find min count ngrams per user
    """
    tweets_per_user = get_json_from_file(filename)

    # fix the type of the expected value
    for user, vals in expected.items():
        expected[user] = [tuple(v) for v in vals]

    recreate_msg = (f"\n\nTo recreate this test in ipython3, run:\n"
                    f"  import util\n"
                    f"  import {MODULE}\n"
                    f"  tweets_per_user = util.get_json_from_file('{filename}')\n"
                    f"  expected = {str(expected)}\n"
                    f"  actual = {MODULE}.find_min_count_ngrams(tweets_per_user, {n}, {min_count})\n")

    try:
        actual = hw6.find_min_count_ngrams(tweets_per_user, n, min_count)
    except Exception as e:
        # catch all exceptions generated by the function and print
        # the recreation message and the stack trace.
        msg = f"Exception caught: {e}\n" + recreate_msg + \
            f"\nException {traceback.format_exc()}"
        pytest.fail(msg)

    # check that the result is not None
    nn_error = get_none_error(actual)
    if nn_error:
        pytest.fail("\n" + nn_error + recreate_msg)

    error_msg = get_user_to_list_error(actual, expected, True)
    if error_msg:
        pytest.fail("\n" + error_msg + recreate_msg)
        
    
##################################################
#                                                #
# Helper functions specific to HW #6             #
#                                                #
##################################################

def get_none_error(actual):
    """
    Generate an error if the actual value is unexpectedly none.
    """

    msg = ("\n\nThe function returned None when a value "
           "other than None was expected.\n"
           "Common sources of this problem include:\n"
           "  - including a print statement rather than a return statement, and\n"
           "  - forgetting to include a return statement along some path in the compuation.\n")
    if actual is None:
        return msg
    return None


def get_key_error(actual, expected):
    """
    Generate an error if the actual value and the expected value have different keys.
    """

    # generate an error if the keys do not match, None otherwise
    rmsg = ("  A key '{}' appears in the expected result\n"
            "  and is missing from the actual result.\n")
    for expected_key in expected:
        if expected_key not in actual:
            return rmsg.format(expected_key)
    
    rmsg2 = ("  A key '{}' appears in the actual result\n"
             "  that does not appear in the expected result.\n")
    for actual_key in actual:
        if actual_key not in expected:
            return rmsg2.format(actual_key)

    # no error: the keys match
    return None


def get_tweet_error(actual, expected):
    """
    Generate an error if the actual and expected tweet do not match
    """
    key_error = get_key_error(actual, expected)
    if key_error:
        return key_error

    # check the values
    msg3 = ("The type of the value associated with the key '{}' is incorrect:\n"
            "  Expected type: {}\n"
            "  Actual type: {}\n")

    msg4 = ("The value associated with the key '{}' is incorrect:\n"
            "  Expected value: {}\n"
            "  Actual value: {}\n")
    for key, expected_val in expected.items():
        actual_val = actual[key]
        if not isinstance(actual_val, type(expected_val)):
            return msg3.format(key, type(expected_val).__name__, type(actual_val).__name__)

        if actual[key] != expected[key]:
            return msg4.format(key, expected[key], actual[key])

    # No error detected
    return None


def get_tweet_list_error(actual, expected):
    """
    Generate an error if the actual list of tweets does not match
    the expected list of tweets.  Return None otherwise.
    """
    msg1 = (f"Expected a list of simple tweets.\n"
           f"  Actual return type: {type(actual).__name__}\n")

    if not isinstance(actual, type(expected)):
        return msg1

    if len(actual) != len(expected):
        return (f"The actual length ({len(actual)}) of the list does not\n"
                f"match the expected length ({len(expected)}).")


    msg2 = "The actual result and the expected result do not match at index {}.\n"
    for i, actual_val in enumerate(actual):
        if not isinstance(actual_val, dict):
            return (f"The result is a list as expected, but the value at\n"
                    f"index {i} has the wrong type.\n"
                    f"  Expected type: dict\n"
                    f"  Actual type: {type(actual_val).__name__}\n")

        error_msg = get_tweet_error(actual_val, expected[i])
        if error_msg:
            return msg2.format(i) + error_msg

    # no error
    return None


def get_list_error(actual, expected, expected_type_str, sort_before_check=False):
    """
    Generate an error if the actual and expected list are not the same
    """

    if sort_before_check:
        actual = sorted(actual)
        expected = sorted(expected)

    if actual == expected:
        return

    if not isinstance(actual, list):
        msg = (f"\n\nThe actual value has the wrong type.\n"
               f"  Expected type: {expected_type_str}\n"
               f"  Actual return type: {type(actual).__name__}\n")
        return msg

    if len(actual) != len(expected):
        msg = (f"\nThe actual length ({len(actual)}) of the result\n"
               f"does not match the expected length ({len(expected)}) of the result")
        return msg

    msg3 = ("The type of the actual value is a list as intended,\n"
            "but the type of the value at index {} is incorrect.\n"
            "  The actual value at index {} has type {}.\n"
            "  The expected type is {}.\n")

    msg4 = ("The actual value is a list as intended,\n"
            "but the value at index {} is not correct:\n"
            "      The actual value at index {} is {}\n"
            "      The expected value is {}\n")

    for i, (actual_val, expected_val) in enumerate(zip(actual, expected)):
        # check the type
        actual_val_type = type(actual_val)
        expected_val_type = type(expected_val)
        if not isinstance(actual_val, expected_val_type):
            return msg3.format(i, i, actual_val_type.__name__, expected_val_type.__name__)

        # check the value
        actual_val_str = str(actual_val) if not isinstance(actual_val, str) else '"' + actual_val + '"'
        expected_val_str = str(expected_val) if not isinstance(expected_val, str) else '"' + expected_val + '"'
        if actual_val != expected_val:
            return msg4.format(i, i, actual_val_str, expected_val_str)



def get_user_to_list_error(actual, expected, sort_before_check=False):
    # make sure the result is a dictionary
    msg1 = (f"Expected a dictionary that maps user screen names to lists of strings.\n"
            f"  Actual return type: {type(actual).__name__}\n")
    if not isinstance(actual, type(expected)):
        return msg1

    # check the keys
    key_error = get_key_error(actual, expected)
    if key_error:
        return key_error

    # check the values
    msg4 = ("The value associated with the key '{}' in the result is incorrect.\n"
            "It should be a list of strings.  The error may be that\n"
            "  - the type of the value is incorrect,\n"
            "  - the length of list is incorrect, or\n"
            "  - the values in the list are wrong.\n"
            " Interpret what follows with those possibilities in mind\n\n")
    for key, expected_val in expected.items():
        print(actual[key])
        print(expected_val)
        error_msg = get_list_error(actual[key], expected_val, "list[str]", sort_before_check)
        if error_msg:
            return msg4.format(key) + error_msg
    

def gen_recreate_header(tweet_filename, lb=None, ub=None):
    if lb is not None:
        tweets_str = f"  tweets = util.get_json_from_file('{tweet_filename}')[{lb} : {ub}]\n"
    else:
        tweets_str = f"  tweets = util.get_json_from_file('{tweet_filename}')\n"

    msg = (f"\n\nTo recreate this test in ipython3, run:\n"
           f"  import {MODULE}\n"
           f"  import util\n") + tweets_str

    return msg

def get_dict_framework_error(actual, expected, type_str):
    # make sure the result is a dictionary
    msg1 = (f"Expected a dictionary that {type_str}.\n"
            f"  Actual return type: {type(actual).__name__}\n")
    if not isinstance(actual, type(expected)):
        return msg1

    # check the keys
    key_error = get_key_error(actual, expected)
    if key_error:
        return key_error

    # no error in framework
    return None
    
